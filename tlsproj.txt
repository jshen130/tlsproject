TLS Project Writeup
===================

1. All messages in this protocol have a type field sent in plaintext. If an attacker can alter packets being sent to and from the server, explain how it can launch a DoS attack on the server or client in a way that does not reveal it’s involvement.

Since the server will never preemptively send messages, it will drop any unexpected message types. Although the specs do not mention what the server behavior is in the event of such an out of order message type (it could return an error message to tell the client to drop the connection and retry or drop the packet and wait for the correct type), it is evident that the ability to tamper with this field (which isn't even encrypted!) could result in a Denial of Service attack. By modifying the message type en route to either end, any handshake attempts will fail, since on the client side an unexpected response type will exit the program and drop the connection immediately, while on the server side, regardless of its reaction, the proper response to the client will not be sent, either stalling or terminating the handshake. This method makes the attacker's involvement more discreet, as message type is parsed first without comparing the expected response to the message contents, the error can be attributed to the fault of the other end of the communication, versus if the attacker tampered with the data such that when the messages are being decrypted, the decryption fails making it obvious it was altered. 

2. Look at the function random int(). How are the ”random” numbers chosen? Can an attacker learn any information about our system or other random values if they know our method? Suggest a way that a man-in-the-middle might be able to use this to break our encryption. Tip: try printing random values as they are chosen during the handshake.

The random_int() function calls the ANSI C rand random number generator with the seed set to the current time - which has low entropy and can be observed or predicted, reducing the effectiveness of the random values generated. If this weren't bad enough, the function makes a new generator each call with the same seeding method. This means, if successive calls to random_int() happen within a second of each other, since the seed is based on seconds, then you would get the same result each time. Given the latency involved in a communication channel, it is common for this handshake to be completed within a second, meaning the client hello message random value is likely to be the same as the premaster secret random value. If an attacker learned our methods of generating random numbers, they could first of all, easily brute force the number of values random_int() would generate if they knew the date you were initiating the connection. Or if they were monitoring our traffic as a man-in-the-middle, they could see our system time and replicate our random number generation process. If they were also able to learn our master secret generating technique (sha256 hash of concatenated values), then they could easily learn the symmetric key generated through the handshake. By observing the exchange, they could compute the client and server hello random values themselves using the packet timestamps and comparing them to what is actually exchanged to affirm both ends system times. Next, the attacker wouldn't be able to read the encrypted premaster secret, but by generating random values based on either when the premaster secret packet is sent or how much time has elapsed since the hello message exchange, they will be able to find the right premaster secret and by extension the symmetric master secret used after the exchange, breaking the encryption.

3. We have talked about a downgrade attack in class before. Assuming that the server and client supported multiple cipher suites (some weaker than others), show how a downgrade attack might be possible on the Terribly Lacking Security handshake. Then suggest a method or adaptation to the handshake that would mitigate a downgrade attack.

A downgrade attack forces a client or server to use a weaker encryption protocol to communicate, making the connection more vulnerable to attack, by dropping handshake attempts proposing more secure protocols. This is entirely possible for our TLS handshake, as a man-in-the-middle could drop hello message that contain a strong cipher suite, returning a reset and making the sender think the recipient doesn't support that suite and try another cipher, which the attack would only allow if it was a weaker suite. One way to mitigate such attacks would be to include the list of supported or preferred cipher suites in the hello message. This way, if the server receives a message with a weak cipher choice but notices a mutally supported and stronger cipher is in the message's cipher suite list, the server can suspect a downgrade attack attempt and respond with the stronger suite (that it knows the client can handle). This also requires having a final exchange before terminating the end of the handshake that include a hash of all preceding messages to make sure they were the same on both ends, indicating no MITM alteration of the client supported cipher suite list to confuse the server, as then the hashes would be different.

4. List as many security flaws in the Terrible Lacking Security protocol/implementation as you can find and suggest ways that you might fix them. (Note: The flaws discussed above do not count)

REPLAY ATTACKS: This protocol is susceptible to replay attacks to cause handshake failures. If a MITM intercepts and saves the (Premaster Secret)_{E_{server_public_key}} message from the client to the server, then he could replay this message to the server when any client is attempting to initiate a connection, causing the server and client to calculate different master secrets (since the server doesn't get the new client's random premaster secret and is using the premaster secret generated by the handshake the MITM was listening on). Neither side should assume an attacker since everything decrypts properly, and may attribute the mismatched master secret to errors in calculations at the other end. This could be prevented by including the Nonces that are the hello message random values in the premaster secret exchange to verify session authenticity.

SERVER IMPERSONATION: Another MITM attack (that may have required some IP or DNS spoofing before hand) could allow the attacker to break the encryption, causing the client to think the attacker is the server (the server knows it is talking to the attacker though). We already know it is easy to observe the hello message random values from either end for use in generating the master secret since they are not encrypted, but it is difficult to get the premaster secret (generated by the client and encrypted with the server public key). However if an attacker intercepts the client's certificate message to the server and gives the server its own certificate, since no identity information was exchanged earlier, this is the only time the server learns about the "client" (attacker in this case)'s identity from the certificate (unless it has an idea based on IP, but that could be spoofed). Next, the attacker continues normalled, passing the server's certificate to the client and the client's encrypted premaster secret message to the server. However, when the server returns the complete master secret, it is encrypted with the attacker's public key, allowing them to decrypt it to get the master secret without getting the premaster secret. Next, since the attacker knows the client's public key, they just have to give the client the (secret)_{E_{client_public_key}} that they expected. Now the attack can decrypt any message from the client to the server. A fix for this kind of attack could be to include the identity of the sender and intended recipient when sending the premaster secret and confirming the master secret to alert either party of intermediate intervention. 

LENGTH EXTENSION: If the attacker knew the master secret generation process (hash of concatenated values), (12 -> 12PADDING, 34PADDING <- 34)??
